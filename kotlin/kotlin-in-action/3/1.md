# 클래스와 인터페이스

## 코틀린 인터페이스

코틀린 인터페이스는 자바8 인터페이스와 비슷하다. 자바와 똑같이 interface 용어를 사용한다.

```kotlin
// 선언
interface Clickable{
    fun click()
}
```

이제 위의 인터페이스를 구현해보자.

```kotlin
// 구현 
class Button: Clickable{
    override fun click() = println("i was clicked")
}
```

코틀린은 자바와 다르게 상속과 구현 모두 콜론(:)으로 처리한다.&#x20;

자바의 @Override와 비슷한 override변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 오버라이드한다는 표시다. 주의할 점은 코틀린에서는 이 override 변경자를 꼭 사용해야 한다는 것이다. 실수로 상위 메서드를 오버라이드하는 것을 방지해 줄 것이다.&#x20;

코틀린 인터페이스도 자바의 디폴트 메서드처럼 구현이 있는 메서드를 정의할 수 있다. 차이점은 자바에서는 default를 붙여야 하지만 코틀린은 단지 일반 메서드처럼 내용을 추가하면 된다.&#x20;

```kotlin
interface Clickable{
    fun click() // 추상 메서드
    fun showOff = println("I'm clickable!") // 디폴트 구현
}
```

이름과 시그니쳐가 같은 메서드에 대해 둘 이상의 디폴트 구현이 있는 경우 인터페이스를 구현하는 하위 클래스는 명시적으로 새로운 구현을 제공해야 한다. 즉, 오버라이드를 반드시 해야한다.

상위 타입의 구현을 호출할 때는 자바와 마찬가지로 super를 사용한다. 하지만 자바는 Clickable.super.showOff()라면 코틀린은 super\<Clickable>.showOff() 처럼 꺽쇠 괄호 안에 기반 타입 이름을 지정한다.

```kotlin
interface Focusable{
    fun showOff = println("I'm focasable!") // 디폴트 구현, Clickable과 이름 시그니쳐가 같다.
}

class Button: Clickable, Focusable{
    override fun click() = println("i was clicked")
    override fun showOff(){
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```



## Open, Abstract, Final

