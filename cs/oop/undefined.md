# 개요

## 객체지향 프로그래밍의 등장이유

객체지향 프로그래밍 전에 절차지향 프로그래밍을 많이 사용했다고 한다.

절차지향이란 데이터와 기능을 명확히 분리하고 함수로 기능을 프로그래밍하는 방식이다.

간단하고 복잡하지 않은 프로그래밍에는 적합하지만, 점점 복잡해지거나 규모가 커질수록 변경과 확장에 큰 어려움이 있다.

왜냐하면 데이터, 기능 위주로 설계를 했으며 서로 밀접하게 얽혀있어 강하게 결합되어 있기 때문이다.

때문에 사람들은 더 좋은 설계가 필요했고 때문에 객체지향 프로그래밍이 등장하였다.

\


## 객체지향 프로그래밍이란

객체지향 프로그래밍을 한다는 것은 객체 스스로 책임있는 행동을 하며 다른 객체와 원할한 협력을 수행하는 객체들로 이루어진 공동체를 구성하는 것과 같다.&#x20;

역할, 책임, 협력, SOLID로 유명한 5대원칙, 객체지향 3가지의 특성을 통해 객체지향을 이해해보도록 하자.

\


### **역할, 책임, 협력**

역할과 책임, 협력이라는 관점을 통해 객체를 잘 설계하고 프로그래밍할 수 있다.&#x20;



* 협력

어떤 객체가 기능 수행하던 중 책임이 없는 행동은 다른 객체(그 행동에 책임을 가지고 있는)에게 도움을 요청을 한다.

요청을 받은 객체는 성실히 요청에 응답할(도울) 의무가 있다.

기능 수행을 위해 서로 요청하고 응답하고 도와주는 것을 객체 간 협력이라고 한다.

\


* 책임

요청과 응답에 의무가 있는 객체는 의무에 책임이 있다고 할 수 있다.&#x20;

위에서 말했던 것처럼 기능을 원활히 수행하기 위해 필요하다면 도움을 요청을 해야하며, 요청이 오면 성실히 도움을 줘야할 의무 즉, 책임이  있다는 것이다.

책임은 객체가 외부에 제공하는 기능의 목록이라고 볼 수 있다. 따라서 책임은 객체의 인터페이스를 구성한다고 할 수 있다.

책임을 갖는 객체는 자율성과 능동적으로 자신의 맡은 책임을 다한다.

자율성이란 객체가 스스로 판단하고 행동을 취하는 것을 뜻한다. 실제 커피는 단지 마셔지는 수동적인 존재이지만, 객체지향에서의 커피는 소비하겠다는 요청을 받으면 스스로 이 요청에 대해 판단을 한 뒤 응답하는 자율적인 객체이다.

\


* 역할

역할은 책임의 집합이다. 역할에 필요한 책임을 다 하는 객체는 언제든지 기존 객체를 대체할 수 있다.

로미오 역할을 예를들면 로미오의 역할은 대본을 외웠고 연기를 한다는 책임의 집합만 있다고 치자 그럼 필자도 대본을 다 외우고 연기를 하기만 한다면 로미오 역할을 맡을 수 있다. 왜냐하면 잘생기거나 연기를 잘하는 책임은 현재로서는 없으니까 흑&#x20;

어떤 객체이든지 역할에 충족하는 책임만 있다면 대체가 가능하다.

****

### **SOLID**

SOLID는 로버트 마틴이 객체지향 설계의 5가지 기본원칙을 마이클 패더스가 첫글자만 따서 기억하기 쉽게 소개한 것이라고 한다.



1\. SRP(Single Responsibility Principle) - 단일책임원칙

객체에 하나의 책임만을 부여해 변경이 일어나도 파급효과가 적게 설계해야한다.



2\. OCP(Open-Closed Principle) - 개방폐쇠원칙

확장에는 열려있으나 변경에는 닫혀 있어야한다.

다형성을 이용해 확장에 열려있게하며, 구현 객체를 직접 변경하는 것이 아닌 DI(Dependency Injection)를 이용해 변경에 닫게끔 해야한다.



3\. LSP (Liskov Substitution Principle) - 리스코프 치환원칙

다형성에 하위 클래스는 인터페이스 규약대로 정확히 지켜야한다.\


4\. ISP(인터페이스 분리원칙)

범용 인터페이스 하나보다 특정 인터페이스로 나누어 명확하고 대체 가능한 인터페이스가 좋다.\


5\. DIP(의존관계 역전 원칙)

구체화 대신 추상화를 의존한다.

프로그래머가 구현객체를 직접 생성하는 것이 아닌 IoC(Inversion of Control)컨테이너가 객체를 DI(Dependency Injection)하여 구현 객체를 의존하는 것이 아닌 인터페이스를 의존하게 설계한다.

\


### **객체지향 3가지 특성**

1\. 다형성

역할에 의존하여 역할에 충족하는 객체는 서로 대체 가능하게 조립 가능함으로써 변경에 유연함을 갖는다.\


2\. 캡슐화

내부 구현코드를 숨겨 변경에 유연한 설계를 한다. 노출 될 필요 없는 요소는 숨겨 다른 개발자의 실수를 줄이고 보안성을 높인다.\


3\. 상속&#x20;

부모 클래스의 프로퍼티와 메서드를 물려 받아 재사용가능하고 오버라이딩을 통해 다형성을 만족한다.\


####

## 객체지향 설계방법

1\. 사용자 관점으로 도메인을 파악하고 이를 추상화하고 단순화하여 도메인 모델을 추출한다.&#x20;

2\. 각 도메인 끼리의 협력을 정의하여 객체에 적절한 책임을 분담한다.

3\. 앞에서 추출한 인터페이스 대로 구현한다.

\


## 결론

객체지향 프로그래밍은 복잡하고 규모 있는 프로젝트에서 변경과 확장에 좀 더 유연한 설계를 가능하게하는 프로그래밍이다.

자율성과 책임을 가지는 객체를 설계함으로써 변경에 유연하고 확장에 열려있어 유지보수하기 유용하고 재사용성이 증가한다.

이를 위해 인터페이스와 구현을 분리하여 자유롭게 메서드를 구현하고 변경할 수 있어야한다.

\


TDD와 함께 책임을 기반으로 객체지향 설계를 하고 SOLID 원칙도 참고하면 좋은 객체지향 프로그래밍을 할 수 있을 것 같다.

다음 블로그는 위의 방식대로 실제 코드를 구현하여 연습해본 것을 주제로 써 봐야겠다.

\


참고

객체지향의 사실과 오해(조영호), 스프링 기본 이해(김영한)
