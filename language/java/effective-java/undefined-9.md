# 직렬화

직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로부터 다시 객체를 재구성하는 메커니즘(역직렬화)을 뜻한다.



## 85. 자바 직렬화의 대안을 찾으라&#x20;

* 자바 역직렬화에 사용되는 readObject 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들 수 있는 마법 같은 생성자이다.&#x20;
* 신뢰할 수 없는 스트림을 역직렬화해 공격당할 수 있다.&#x20;
* 따라서 json이나 Protocol Buffers 처럼 다른 데이터 표현 방식을 사용하자&#x20;



## 86. Serializable을 구현할지는 신중히 결정하라&#x20;

* 어떤 클래스의 인스턴스를 직렬화 할 수 있게하려면 Serializable을 구현하기만 하면 된다.&#x20;
* 하지만 구현하고 릴리스한 뒤에는 수정하기가 어렵다.&#x20;
  * 직렬화된 클래스는 고유 식별 번호를 부여받는데 따로 명시하지 않으면 시스템이 자동으로 클래스 안에 생성한다. 이 때 클래스 수정이 일어나면 직렬버전 UID 값도 변한다. 다시말해, 자동 생성되는 값에 의존하면 쉽게 호환성이 깨진다.
  * 85처럼 버그와 보안 구멍이 생길 위험이 높다. 공격자가 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출될 수 있다.&#x20;
  * 테스트할 것이 늘어난다.&#x20;
  * 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 되며, 인터페이스도 확장해서는 안된다. 확장할 때 큰 부담이 될 것이다.&#x20;
  * 내부 클래스는 직렬화를 구현하지 말아야한다. 내부 클래스에는 바깥 인스턴스에 대한 정보가 자동으로 추가 되는데, 이 때 어떻게 추가되는지는 분명하지 않으므로 직렬화 형태도 분명하지 않다.&#x20;



## 87. 커스텀 직렬화 형태를 고려해보자&#x20;

* 정말 직렬화가 필요하고 객체의 물리적 표현과 논리적 표현의 차이가 크다면 커스텀한 직렬화 형태를 고려하자.
* writeObject와 readObject를 직접 구현하는 등 커스텀한 직렬화를 고려하자.&#x20;
* transient 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는것을 표시한다.&#x20;



## 88.readObject 메서드는 방어적으로 작성하라&#x20;

* readObject는 매개변수로 바이트 스트림을 받는 생성자라 할 수 있다. 하지만 불변식을 깨트릴 의도로 임의 생성한 바이트 스트림을 건내는 문제가 있을 수 있기 때문에 방어적 으로 작성해야 한다.
* private이어야 하는 객체 참조 필드는 방어적 복사를 하자&#x20;
* 복사 뒤에는 모든 불변식을 검사하자
* 직접적이든 간접적이든, 재정의할 수 있는 메서드는 호출하지 말자.



## 89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거타입을 사용하라&#x20;

* 싱글턴 패턴의 클래스가 implements Serializable을 추가하면 더 이상 싱글턴이 아니게 된다. 어떤 readObject 메서드를 사용하던 초기화될 때 인스턴스와는 별개인 인스턴스를 반환하기 때문이다.&#x20;
* readResolve 기능을 사용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다.&#x20;
* 하지만 readResolve를 사용해 역직렬화된 인스턴스에 접근하지 못하는 방법은 깨지기 쉽고 신경을 많이 써야 한다. (객체 참조 타입 인스턴스 필드 모두 transient로 선언해야 함 그렇지 않으면 readResolve 메서드가 수행되기 전에 역직렬화된 객체의 참조를 공격할 여지가 있음)
* 반면 열거타입은 선언한 상수 외의 다른 객체는 존재하지 않음을 쉽게 구현할 수 있고 자바가 보장해준다.















