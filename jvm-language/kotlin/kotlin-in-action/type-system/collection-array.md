# 컬렉션과 배열

## 널 가능성과 컬렉션&#x20;

컬렉션 안에 원소가 널 가능성의 여부는 변수 값의 널 가능성 여부처럼 중요하다.&#x20;

List\<Int?>는 Int? 타입의 원소를 갖을 수 있다. List\<Int>?는 리스트를 가리키는 변수는 널이 될 수 있지만 원소는 널이 될 수 없다. List\<Int?>?는 리스트 변수가 널이 될 수 있고 리스트 원소도 널이 될 수 있다.

컬렉션에 널 값을 걸러내는 경우가 자주 있기 때문에 표준 라이브러리에서 filterNotNull이라는 함수를 제공해준다.&#x20;

`val validNumbers : List<Int> = numbers.filterNotNull()`

이 함수는 널을 제거해주기 때문에 결과 타입이 널이 될 수 없는 타입 List\<Int>가 된 것을 확인할 수 있다.



## 읽기 전용과 변경 가능한 컬렉션

코틀린 컬렉션과 자바 컬렉션의 가장 큰 차이 중 하나는 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 데이터를 변경하는 인터페이스를 분리했다는 점이다.&#x20;

kotlin.collections.Collection은 가장 기초적인 인터페이스로 접근 즉, 조회에 대한 기능만을 정의한 인터페이스이다. 원소를 이터레이션이나 컬렉션 크기를 얻고, 어떤 값이 들어 있는지 검사하는 등의 기능은 제공하지만 원소를 추가하거나 삭제하는 메서드는 없다.&#x20;

데이터를 수정하려면 kotlin.collections.MutableCollection 인터페이스를 사용하면 된다. 이 인터페이스는 위의 Colleciton 인터페이스를 바탕으로 추가, 삭제 등의 데이터 변경 메서드를 확장해서 제공한다.&#x20;

<img src="../../../../.gitbook/assets/file.excalidraw.svg" alt="extends collection" class="gitbook-drawing">

변수에서 val와 var를 구별하는 것처럼 컬렉션을 사용할 때도 읽기 전용 인터페이스를 사용하는 것을 습관화하자. 이렇게  역할을 구별 함으로써 데이터에 어떤 일이 생길지 쉽게 파악할 수 있다.&#x20;

```kotlin
fun <T> copyElements(source: Collection<T>, target: MutableCollection<T>){
    ~~  
}
```

위의 코드에서 우리는 source 컬렉션은 변경되지 않지만, target 컬렉션은 변경될 수 있는 것을 쉽게 알 수 있다.

컬렉션을 사용할 때 염두에 둬야 할 점은 읽기 전용 컬렉션이라고 꼭 변경 불가능한 컬렉션일 필요는 없다는 점이다.&#x20;

<img src="../../../../.gitbook/assets/file.excalidraw (1) (3).svg" alt="List, MutableList" class="gitbook-drawing">

어떤 컬렉션에 대해 참조할 때 읽기 전용으로 참조할 수도 있고 변경 가능한 인터페이스로 참조할 수도 있는 것이다.&#x20;

MutableCollection은 Collection을 확장했기 때문이다. 따라서 이 컬렉션을 참조하는 다른 코드를 호출하거나 병렬 실행하면 컬렉션 도중 내용이 변경되는 상황이 생긴다. 따라서 읽기 전용 컬렉션이 항상 스레드 안전하지는 않다.

다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화하거나 동시 접근을 허용하는 데이터 구조를 활용해야 한다.&#x20;



## 코틀린 컬렉션과 자바&#x20;

코틀린 컬렉션은 자바 컬렉션과 동일하다고 했는데 어떻게 읽기 전용과 변경 가능 컬렉션을 구분할 수 있는 것일까?&#x20;

코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용과 변경 가능한 인터페이스를 제공한다.

<img src="../../../../.gitbook/assets/file.excalidraw (1).svg" alt="" class="gitbook-drawing">



## 컬렉션을 플랫폼 타입으로 다루기





## 객체의 배열과 원시 타입의 배열







