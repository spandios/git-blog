# 객체 생성과 파괴

## 1. 정적 팩토리 메서드를 고려하자

객체 생성시 생성자 대신 정적 팩토리 메서드도 고려하자.

#### 장단점

* 장점
  * 하위 클래스같이 여러 객체를 반환할 수 있어 확장성이 좋다.
  * 함수명으로 더 명확하게 구별 가능
  * 여러 생성자가 필요할 때 생성자는 한 시그니처로 매개변수를 통해 제한을 벗어날 수 있지만, 가독성이 좋지 않다.
  * 정적 팩토리메서드는 함수명으로 어떤 객체를 제공할건지 분명하다.
  * 인스턴스를 매번 생성하지 않고 미리 만들어둔 인스턴스나 변수를 캐싱할 수 있다.
* 단점
  * 생성자 대신 정적 팩터리 메서드만 제공하면 상속이 불가능하다
  * 상속은 public 또는 protected 생성자가 필요하다.
  * 프로그래머가 처음에 찾기 힘들다.

#### 많이 쓰는 명명 방식들

* from : 매개변수를 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
* of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
* valueOf : from과 of의 더 자세한 버전
* getInstnace : 매개변수로(받는다면) 명시한 인스턴스를 반환
  * StackWalker luke = StackWalker.getInstance(options)
* newInstnace : getInstnace와 같지만 매번 새로운 인스턴스 생성
* get\[Type] : getInstance와 같지만 \[Type]에 해당하는 타입 반환
  * FilesStore fs = Files.getFilestore(path)
* new\[Type] : newInstance와 같지만 \[Type]에 해당하는 타입 반환
* type : getType, new Type의 간결한 버전
  * Collections.list()

## 2. 생성자에 매개변수가 많다면 빌더를 고려하자.

4개 이상의 파라미터가 있다면 빌더를 고려하자.

단계적 생성자: 여러 매개변수는 가독성이 안좋지만 정확한 객체를 생성해줌.

자바빈즈: 가독성은 좋지만 필수적인 값을 넣었는지의 검증은 힘들어 안정성이 떨어짐

단계적 생성자만큼의 안정성과 자바빈즈 방식의 가독성을 갖춘 빌더를 사용하자!



### 3. Private 생성자나 열거타입으로 싱글턴임을 보증하자.



### 4. Private 생성자로 인스턴스화를 막자.

util같이 정적인 변수 메서드만 필요한 클래스가 있다. 이런 클래스는 인스턴스가 필요없으므로 private 생성자를 통해 인스턴스를 막자.



## 5. 자원을 스스로 생성 하지말고 의존 주입을 사용하자.

하나 이상의 자원을 의존하고 그 자원으로 인해 클래스 동작에 영향을 준다면, 싱글턴과 정적 유틸리티 클래스를 사용하는 건 좋지 않다.

필요한 자원(or 자원을 만드는 factory)을 생성자 (or static factory or builder)를 통해 넘겨줌으로써, 유연성과 재사용성 테스트 용이성을 높이자.



## 6. 불필요한 객체 생성을 피하자.

#### 사례

1. String 인스턴스를 만들고 또 String 객체생성

```java
String s = new String("heo");
```

1. 값비싼 객체를 재사용

```java
public class Roman{
	private static final Pattern ROMAN = Pattern.compile(~~);
	static boolean isRoman(String s){
		return ROMAN.matcher(s).matches();
	}
}
```

1. 오토박싱(기본 타입과 박싱된 기본타입을 섞어 쓸 때 자동으로 상호변환해주는 기술)

* 박싱된 기본타입보단 기본 타입을 사용하자
* 오토박싱을 반복문 등에서 자주 호출되면 성능에 매우 안 좋다

### 7. 다 쓴 객체 참조 해제

다 쓴 참조를 계속 보유해서 가비지 컬렉션에서 못 가져가는지 체크하자.

1. 자기 메모리를 직접 관리하는 클래스
2. 캐시에 객체 참조를 넣고 보유기간을 최적화 하지 않을 때
3. 리스너를 등록만하고 해제는 하지 않을 때

#### WeakHashMap이란?

// TODO



### 8. 객체 소멸자인 finalizer와 cleaner 사용을 피하자

실행이 예측할 수 없고 오직 가비지 컬렉션에 달려있는 객체 소멸자 사용을 지양하자.

안전망 즉, 객체 참조를 해제하는 것을 까먹었을 때를 보완하기 위한 보험을 제외하면 지양하자.

속도, 안정성, 보안에서 좋지 않다.



### 9. 자원을 꼭 회수해야하는 경우 Try with Resources를 사용하자

* try finally
  * 자원이 2개이상일 때 복잡해짐
  * finally에서도 오류가 발생할 수 있으므로 자원 해제가 안될 수도 있음.
* try with reources
  * try에 자원 객체를 전달하면, try 코드 블록이 끝나면 자동으로 자원을 종료해주는 기능 이다.
  * resource는 autoclosable 인터페이스를 구현해야함.
