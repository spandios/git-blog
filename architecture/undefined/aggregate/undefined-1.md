# 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.

```java
// 리포지터리에 애그리거트를 저장한다는 것은 
// 애그리거트 전체를 영속화 한다는 것이다.
orderRepository.save(order);
```

## 애그리거트 참조 방식

애그리거트가 다른 애거리거트를 참조할 수 있다. 애그리거트를 참조한다는 것은 애그리거트 루트를 참조 한다는 것이다.



### 애그리거트 객체 참조&#x20;

```java
class Orderer{
    private Member member; // 필드로 다른 애거리거트 루트를 참조한다.
}

class Member{
    private String name;
}

```

위의 코드처럼 필드를 통해 다른 애그리거트의 참조를 쉽게 할 수 있다.&#x20;

하지만 이 방식에는 2가지 고민해야할 점도 존재한다.

* 쉽게 참조할 수 있어 오용할 수 있다.

만약 애그리거트 객체가 좋지 못한 캡슐화로 설계 됐다면, 애그리거트가 책임과 권한을 넘어 다른 애그리거트의 상태를 변경하거나 조회하는 등의 문제를 발생할 수 있다.

편하게 접근이 가능하니 결합도가 높아질 확률도 있다.

* 확장성&#x20;

각 애그리거트마다 다른 DB를 사용한다면 JPA와 같은 단일 기술을 사용할 수 없다.



### ID값을 이용한 참조&#x20;

ID 참조는 객체 그 자체를 참조하는게 아니라 외래키로 참조하는 것 처럼 id값을 통해 다른 애그리거트를 참조한다. 이 방식은 위에서 고민해야할 점을 덜어준다.

애그리거트의 경계를 명확히 하기 때문에 결합도와 복잡도가 낮아질 수 있으며, 다른 구현 DB 기술을 이용하는 데 걸림 돌이 없기 때문이다.

하지만 ID를 이용한 참조는 조회 성능은 각별히 신경을 써야한다. 조회 대상 N개일 때 N개를 읽어오는 한 번의 쿼리와 연관된 데이터를 읽어오는 쿼리를 N번 실행하는 N +1 문제가 있을 수 있기 때문이다.

예를들어, 주문이 10개가 있는 상황에서 주문을 조회 하면서 주문한 상품 정보도 가져와야 한다면 11번의 쿼리가 나가는 것이다.&#x20;

```java
List<Order> dtos = orders.stream()
    .map(order -> {
        ProductId prodId = order.getOrderLines().get(0).getProductId();
        Product product = productRepository.findById(prodId); // 주문 개수만큼 추가적으로 쿼리가 호출 된다.
    }).collect(toList());
```



이를 위해서는 Join이 필요하고 조회 전용 쿼리를 통해 해결하도록 하자.





