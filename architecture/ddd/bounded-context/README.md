# 바운디드 컨텍스트

## 바운디드 컨텍스트란?

도메인 모델은 어떤 문맥안에서 같은 용어인데도 **다른 의미**로 사용되거나, 같은 의미인데도 **다른 용어**로 사용 될 수 있다.&#x20;

예를 들어 상품은 카탈로그, 재고 관리, 주문에서의 상품은 모두 같은 '상품'이라는 용어를 사용하지만, 실제로 그 안에서 의미와 사용은 다를 수 있다.&#x20;

또, 주문 도메인에서는 주문자이지만, 회원 도메인에서는 회원이라는 용어를 사용하는 것 처럼 같은 개념을 다른 용어로 사용하기도 한다.

도메인 모델은 특정한 문맥 안에서 완전히 의미를 갖는다. 따라서 같은 모델이라도 문맥이 다르면 그 의미가 서로 다를 수 있다.  이렇게 **구분되는 경계**를 **** DDD에서는 **바운디드 컨텍스트(Bounded Context)**라 한다. 바운디드 컨텍스트는 모델의 경계를 결정하며, 한 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.&#x20;



## 바운디드 컨텍스트는 조직 구조나 규모에 따라 결정된다.

규모가 큰 프로젝트에서는 어떤 대규모 도메인 아래에 다시 바운디드 컨텍스트를 나누고, 그것을 담당하는 팀을 구성하는 구조를 가질 수 있다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.44.38.png" alt=""><figcaption></figcaption></figure>

작은 규모의 프로젝트나 기업에선 한 바운디드 컨텍스트를 한 팀이 모두 맡아서 구현하는 구조를 가질 수 있다.

여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때는 논리적으로 컨텍스트를 나누도록 하자. 하위 도메인 모델들이 무분별하게 섞이지 않게 해야하기 때문이다. 아래 그림처럼 물리적으로 하나의 컨텍스트만 가지더라도 내부적으로는 논리적으로 컨텍스트를 분리하는 것이다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.26.54.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.28.39.png" alt=""><figcaption><p>어떤 문맥에 있냐에 따라 도메인은 각각 다른 모델이다.</p></figcaption></figure>



## 바운디드 컨텍스트 구현&#x20;

바운디드 컨텍스트가 도메인 모델만 포함하는 것이 아니라, 표현, 응용, 인프라스트럭처 계층을 모두 포함한다.&#x20;

도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 변경 되기 때문에 테이블도 바운디드 컨텍스트에 포함된다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.32.35.png" alt=""><figcaption></figcaption></figure>

바운디드 컨텍스트는 도메인에 알맞은 아키텍처를 선택하고 적용할 수 있다. 위의 구조를 항상 선택하는 것이 아니라 상황에 맞게 유연하게 아키텍처를 설계하고 적용하도록 하자.



### 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다

단순 CRUD가 필요한 데이터 중심으로 기능이 있기 때문에 따로 도메인 로직을 갖고 있지 않은 아키텍처를 사용하는 것도 좋다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.48.39.png" alt=""><figcaption></figcaption></figure>

### CQRS

{% hint style="info" %}
### CQRS (Command Query Responsibility Segregation)

상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 분리하는 패턴&#x20;
{% endhint %}

한 바운디드 컨텍스트에서 QCRS패턴 대로 명령과 조회를 나눈 구조로 구성할 수 있다. 아래 예시를 보면 왼쪽은 명령 기능만을 제공하기 위해 도메인, 인프라스트럭처 계층을 사용하고 있으며, 오른쪽은 조회 기능만을 제공하기 위해 DAO 계층을 중심으로 사용하고 있는 것을 볼 수 있다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오전 11.51.44.png" alt=""><figcaption></figcaption></figure>

### 서로 다른 구현기술로 구현

각 바운디드 컨텍스트는 서로 다른 기술을 사용할 수 있다. 어떤 바운디드 컨텍스트는 Spring과 JPA로 다른 바운디드 컨텍스트는 grpc와 gorm 등을 사용할 수 있는 것이다.



## 바운디드 컨텍스트 통합

서로 다른 바운디드 컨텍스트가 통신하여 작업을 수행하는 통합 작업은 직접 통합이나 간접 통합의 방식이 있다.

### 직접 통합 = REST API

직접 통합의 대표적인 방법은 HTTP REST API이다. 아래 예시는 어떤 바운디드 컨텍스트에서 추천 바운디드 컨텍스트에게 추천 상품을 REST API로 요청하는 작업을 보여준다.&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오후 5.08.14.png" alt=""><figcaption></figcaption></figure>

1. 자신의 도메인 관점에서 정의된 ProductRecommendationService인터페이스를 정의했다.
2. 실제 구현 클래스인 RecSystemClient는 Infra계층 단에서 위의 인터페이스를 만족하도록 구현 한다.&#x20;
3. RecSystemClient는 외부 추천 바운디드 컨텍스트에게 실제 추천 상품을 요청하고 결과를 받는다.&#x20;
4. 뿐만 아니라 전달 받은 추천 상품을 자신의 도메인 모델에 맞게 끔(Product) 변환하는 작업도 처리함으로써, 정의된 인터페이스를 만족하고 있다.

### 간접 통합 = Message Queue

직접적으로 통합하는 REST API 방법 대신 간접으로도 통합할 수 있다. 대표적인 방법이 메시지 큐를 사용하는 것이다.&#x20;

메시지 큐 방식의 간접 통합 작업에서 중요한 점은 메시지 구조와 누가 그 큐를 제공할지 같은 팀 간의 협의이다.

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-14 오후 5.31.12.png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
마이크로서비스와 바운디드 컨텍스트

마이크로서비스는 애플리케이션을 작은 서비스로 나누어 개발하는 아키텍처 스타일이다.

이 아키텍처는 바운디드 컨텍스트와 잘 어울린다.&#x20;

각 바운디드 컨텍스트는 모델의 경계를 형성하는데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트 별로 모델이 분리된다.&#x20;

코드로 생각하면 바운디드 컨텍스트마다 프로젝트가 분리되는 것이다. 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트 모델이 섞이지 않도록 도와준다.
{% endhint %}

