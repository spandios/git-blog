# 바운디드 컨텍스트 간 관계

## 바운디드 컨텍스트 통합

서로 다른 바운디드 컨텍스트가 통신하여 작업을 수행하는 통합 작업은 직접 통합이나 간접 통합의 방식이 있다.

### 직접 통합 = REST API

직접 통합의 대표적인 방법은 HTTP REST API이다. 아래 예시는 어떤 바운디드 컨텍스트에서 추천 바운디드 컨텍스트에게 추천 상품을 REST API로 요청하는 작업을 보여준다.&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2023-02-14 오후 5.08.14.png" alt=""><figcaption></figcaption></figure>

1. 자신의 도메인 관점에서 정의된 ProductRecommendationService인터페이스를 정의했다.
2. 실제 구현 클래스인 RecSystemClient는 Infra계층 단에서 위의 인터페이스를 만족하도록 구현 한다.&#x20;
3. RecSystemClient는 외부 추천 바운디드 컨텍스트에게 실제 추천 상품을 요청하고 결과를 받는다.&#x20;
4. 뿐만 아니라 전달 받은 추천 상품을 자신의 도메인 모델에 맞게 끔(Product) 변환하는 작업도 처리함으로써, 정의된 인터페이스를 만족하고 있다.

### 간접 통합 = Message Queue

직접적으로 통합하는 REST API 방법 대신 간접으로도 통합할 수 있다. 대표적인 방법이 메시지 큐를 사용하는 것이다.&#x20;

메시지 큐 방식의 간접 통합 작업에서 중요한 점은 메시지 구조와 누가 그 큐를 제공할지 같은 팀 간의 협의이다.

<figure><img src="../../../../.gitbook/assets/스크린샷 2023-02-14 오후 5.31.12.png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
마이크로서비스와 바운디드 컨텍스트

마이크로서비스는 애플리케이션을 작은 서비스로 나누어 개발하는 아키텍처 스타일이다.

이 아키텍처는 바운디드 컨텍스트와 잘 어울린다.&#x20;

각 바운디드 컨텍스트는 모델의 경계를 형성하는데 바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트 별로 모델이 분리된다.&#x20;

코드로 생각하면 바운디드 컨텍스트마다 프로젝트가 분리되는 것이다. 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트 모델이 섞이지 않도록 도와준다.
{% endhint %}

##

## 상류 컴퍼넌트와 하류 컴퍼넌트&#x20;

바운디드 컨텍스트는 어떤 식으로 연결 되기 때문에 다양한 방식으로 관계를 맞는다.&#x20;

가장 흔한 관계는 한쪽에서 API를 제공하고 다른 한쪽에서 그 API를 호출하는 관계이다.&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2023-02-14 오후 5.58.07.png" alt=""><figcaption></figcaption></figure>

기능을 제공하는 쪽을 상류 컴퍼넌트, 기능을 사용하는 쪽이 하류라고 볼 수 있다.

위의 예시에서는 추천 바운디드 컨테스트가 상류 컴퍼넌트이고 카탈로그 바운디드 컨텍스트는 하류 컴퍼넌트이다.



## 공개 호스트 서비스&#x20;

여러 하류 컴퍼넌트 팀이 한 상류 컴퍼넌트를 사용하면, 상류 컴퍼넌트가 여러 하류 컴퍼넌트들의 요구사항을 수용할 수 있는 API를 만들어 이를 서비스 형태로 공개해 서비스의 일관성을 유지할 수 있다. 이런 서비스를 가리켜 **공개 호스트 서비스**라고 한다.

대표적인 예가 검색 서비스이다. 각 컨텍스트 마다 검색 기능을 구현 하기보다는 검색 공개 호스트 서비스를 구축하고 각 바운디드 컨텍스트들이 사용할 수 있도록 한다.&#x20;



<figure><img src="../../../../.gitbook/assets/스크린샷 2023-02-14 오후 6.10.12.png" alt=""><figcaption></figcaption></figure>

물론 공개 호스트 서비스도 상위 컴퍼넌트의 도메인을 사용하고 제공한다. 따라서 각 하류 컴퍼넌트들은 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 모델을 변환하고 사용해야 한다. 앞서 살펴봤던 RecSystemClinet같은 완충재를 사용하는 것이다. 이런 완충재 역할의 계층을 안티코럽션 계층이라고 한다.



## 공유 커널

두 바운디드 컨텍스트가 같은 모델은 공유하는 것이다. 가장 큰 장점은 중복을 줄여준다는 것이지만 그 만큼 팀 간의 소통이 잘 되어야한다.



## 컨텍스트 맵&#x20;

개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다. 따라서 마치 애그리거트처럼 큰 그림으로 볼 수 있게 관계를 표시한 것을 컨텍스트 맵이라고 한다. 아래 그림대로 바운디드 컨텍스트 간의 관계를 표시한 것이다.

<figure><img src="../../../../.gitbook/assets/스크린샷 2023-02-14 오후 6.34.42.png" alt=""><figcaption></figcaption></figure>

각 바운디드 컨텍스트의 경계가 명확하고 서로 어떤 관계를 맺고 있는지 한눈에 확인할 수 있을 것이다.

OHS는 오픈 호스트 서비스를 뜻하고, ACL은 안티코럽션 계층을 뜻한다.&#x20;

컨텍스트 맵은 시스템 전체 구조를 보여준다. 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고 사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는데 도움을 준다.&#x20;

컨텍스트 맵을 그리는 규칙은 따로 없다. 위의 그림처럼 단순하고도 명확하게 각 컨텍스트 간의 관계를 위주로 그리면 된다.
