# Optimistic Lock(낙관적 잠금)

{% hint style="info" %}
Optimistic

낙천주의는 낙관주의 또는 옵티미즘이라고도 하며, 비관주의와는 반대로, 세계는 최종적으로 선을 향해 나아가기 때문에 세상을 희망적으로 밝게 보아야 한다는 생각이나 태도 또는 세계관이다

\-위키백과-
{% endhint %}

낙관적 잠금은 여러 사용자들이 한 데이터에 대해 접근하고 수정하지 않을 것이라고 생각한다. 다시말해 트랜잭션 충돌이 발생하지 않을 것이라는 낙관적인 예측을 토대로 해결책을 제시하는 것이다.&#x20;

낙관적 잠금은 비관적 잠금처럼 다른 트랜잭션의 접근을 아예 막는 방법이 아니라, 변경 데이터를 실제 DBMS에 반영할 때 변경 가능 여부를 체크하는 방식으로 동시성 문제를 해결한다.&#x20;

낙관점 잠금을 구현하려면 애그리거트에 보통 버전을 추가하고 이것을 사용해 수정 가능 여부를 체크한다.

아래 그림을 예시로 낙관적 잠금이 어떻게 버전을 통해 동시성을 해결하는지 흐름을 살펴봄으로써 알아보자

<figure><img src="../../../.gitbook/assets/스크린샷 2023-02-13 오후 6.46.16.png" alt=""><figcaption></figcaption></figure>

1. 스레드1과 스레드2를 보면 버전 5의 애그리거트를 가져오고 있다.
2. 스레드1이 먼저 애그리거트를 수정하고 트랜잭션 커밋까지 성공해 version을 6으로 업데이트 했다.
3. 스레드2는 스레드1보다 늦게 애그리거트를 수정하고 트랜잭션 커밋 하려한다.
4. 이 때 버전을 사용해 수정 가능한지 체크하는데, 스레드2가 가진 애그리거트의 버전은 5인데 막상 수정하는 시점에는 스레드1의 작업으로 인해 버전6이 됐기 때문에, 트랜잭션 커밋을 허락하지 않고 오류를 발생 시킨다.&#x20;
5. 다시말해, 최신 반영된 버전이 아닌 이상 수정을 막는 것과 같다.



## @Version

낙관적 잠금을 구현하려면 JPA는 버전으로 사용할 필드에 @Version 애너테이션을 명시하면 된다.

```java
class Order{
    @Version
    private long version;
}
```





## 애플리케이션 레벨&#x20;

중요한 점은 비관적 잠금처럼 DBMS가 제공하는 Lock기능을 사용하는게 아니라 애플리케이션 단에서 동시성을 해결한다는 점이다. 낙관적 레벨은 동시에 트랜잭션이 들어와 수정하는 것을 막지는 않지만, 애플리케이션 레벨에서 체크함으로써 만약 문제가 있다면 롤백하는 형식이다.&#x20;



## 충돌 발생 시점&#x20;

### VersionConflictException

애플리케이션 단에서 체크하기 때문에 실제 저장하는 단계까지 안 가더라도 미리 체크할 수 있다.

예를들어, 클라이언트에게 버전 정보도 같이 보낸 후, 클라이언트가 다시 서버에 요청을 보낼 때 버전도 같이 보내게 한다. 만약 클라이언트로부터 받은 버전정보가 다르다면 충돌된 상황이므로 VersionConflictException을 통해 유저에게 버전이 충돌 됐다는 것을 알려줄 수 있다. 이것은 이미 누군가 애그리거트를 수정한 시점이라고 알 수 있다.



### OptimisticLockException <a href="#optimisticlockexception" id="optimisticlockexception"></a>

실제 DB단에 저장하려다가 충돌을 감지하면 이 오류를 발생시키며 거의 동시에 애그리거트를 수정해 발생했다고 볼 수 있는 의미로 사용할 수 있다. 충돌 상황에 굳이 구분이 필요 없다면, 그냥 이 오류를 사용하자.



## 엔티티 강제 버전 증가

애그리거트 안에서 루트 엔티티 외에 다른 엔티티나 밸류가 존재하는데, JPA는 이 엔티티를 수정했다고 루트 엔티티의 버전을 증가시키지 않는다. 이 정책은 애그리거트 관점에서 봤을 땐 문제이다. 아무리 루트 엔티티가 변경되지 않더라도 애그리거트의 구성요소가 변경 된 것이기 때문에 온전한 애그리거트를 위해서는 버전을 증가하는게 맞기 때문이다.

LockModeType.OPTIMISTIC\_FORCE\_INCREMENT 옵션은 이 문제를 해결해준다.&#x20;

이 옵션은 엔티티의 상태가 변경되었는지는 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리를 하기 때문에, 루트 엔티티가 아닌 다른 엔티티나 밸류 값을 변경임에도  버전을 증가 시키기 때문이다.&#x20;

```java
@Lock(LockModeType.PESSIMISTIC_WRITE) 
@Query("select m from Member m where m.id := id") 
Optional<Member> findByIdForUpdate(@Param("id") MemberId memberId);
```

## 장단점

### 장점 <a href="#1" id="1"></a>

* 충돌이 많이 발생 안한다면, 여러 트랜잭션을 처리할 수 있어 성능이 좋다.

### 단점 <a href="#1" id="1"></a>

* 잦은 충돌이 일어나는경우 **롤백 처리**에 대한 비용이 많이 들어 오히려 성능이 안 좋아질 수 있다.



따라서 낙관적 잠금은 실제로 데이터 충돌이 자주 발생하지 않는 환경에서 사용하는 게 좋다.



### 참고

[https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/](https://unluckyjung.github.io/db/2022/03/07/Optimistic-vs-Pessimistic-Lock/)



